#!/bin/bash
#
# lsenv - list many aspects of the Mycroft/Minimy/Neon/OVOS environment
#
#+--------------------------------------------------------------------------+
function usage()
# Give help to the user
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo "Name: lsenv - List information about the OVOS environment" 
  echo "Usage: lsenv [OPTIONS]" 
  echo "Where: noclear      Does not clear the screen first"
  echo ""
  echo "OPTIONS:"
  echo "  -h|--help         Give help (this screen)"
  echo "  -v|--verbose      Increase verbosity" 
  echo "  -x|--debug        Print commands and arguments as they are executed"
  exit 51
 }                                         # usage()

#+--------------------------------------------------------------------------+
function parseArgs()
# Parse arguments
# Args: All arguments passed into script
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  while [ -n "$1" ]                        # loop through args passed in
  do
    case "$1" in
      -h|--help)
        usage
        ;;
      -n|--noclear)                        # do not clear the screen
        clear="no"
        ;;
      -v|--verbose) 
        verbose=2
        ;;
      -x|--debug)                          # turn trace on
         set -vx
         ;;
      *)
        echo "ERROR: Too many arguments: $1"
        usage
        ;;
    esac
    shift
  done
 }                                         # parseArgs()

#+--------------------------------------------------------------------------+
function verboseMsg()
# Print message when in verbose mode
# Args: message
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  if [ "$verbose" -gt 1 ]; then    
    echo "$@"
  fi
 }                                         # verboseMsg()

#+--------------------------------------------------------------------------+
function listService()
# List the status of one service 
# Arg 1: service to list
# Arg 2: "root" or "user" service
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local theService=$1
  local serviceType=$2

  local cmd
  local status 
  # RED="\e[31m"              print in colors
  # GREEN="\e[32m"
  # YELLOW="\e[33m"

  if [ "$serviceType" = root ]; then
    cmd="/usr/bin/systemctl status $theService"
  elif [ "$serviceType" = user ]; then
    cmd="/usr/bin/systemctl --user status $theService"
  else                                     # not expected
    echo "INTERNAL ERROR: serviceType = $serviceType"
    exit 4
  fi
  printf "%16s: " "$theService"
  verboseMsg "Running: $cmd ..." 
  cmdOut=`$cmd` 
  verboseMsg "$cmdOut"
  echo "$cmdOut" | grep "active (running)" >/dev/null
  if [ $? = 0 ]; then                      # found "active"
    printf '\e[32m%s\e[0m\n' "active (running)"
  else
    echo "$cmdOut" | grep "Active: failed" >/dev/null
    if [ $? = 0 ]; then                    # found "failed"
      printf '\e[31m%s\e[0m\n' "failed"
    else 
      echo "$cmdOut" | grep "code=exited" >/dev/null
      if [ $? = 0 ]; then                    # found "failed"
        printf '\e[31m%s\e[0m\n' "exited"
      else
        echo "TODO: check for inactive|activating"
      fi
    fi
  fi 
 }                                         # listService()

#+--------------------------------------------------------------------------+
function getCPU()
# Get CPU usage for 4 seconds then average iterations 2-4 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local cpu_total=0
  for i in 1 2 3 4; do
    # Get the first line with aggregate of all CPUs 
    cpu_now=($(head -n1 /proc/stat)) 
    # Get all columns but skip the first (which is the "cpu" string) 
    cpu_sum="${cpu_now[@]:1}" 
    # Replace the column seperator (space) with + 
    cpu_sum=$((${cpu_sum// /+})) 
    # Get the delta between two reads 
    cpu_delta=$((cpu_sum - cpu_last_sum)) 
    # Get the idle time Delta 
    cpu_idle=$((cpu_now[4]- cpu_last[4])) 
    # Calc time spent working 
    cpu_used=$((cpu_delta - cpu_idle)) 
    # Calc percentage 
    cpu_usage=$((100 * cpu_used / cpu_delta)) 
    
    # Keep this as last for our next read 
    cpu_last=("${cpu_now[@]}") 
    cpu_last_sum=$cpu_sum 
    
    if [ "$i" != 1 ]; then                 # use iterations 2-4 
      let cpu_total=$cpu_total+$cpu_usage
    fi
    sleep 1 
  done
  let cpu_usage=$cpu_total/3               # calculate average
  printf "%16s: %s\n" "CPU usage" "$cpu_usage%"
 }                                         # getCPU()

#+--------------------------------------------------------------------------+
function listTemp()
# lstemp - show the temperature of the Raspberry Pi based on
#          the file /sys/class/thermal/thermal_zone0/temp
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local tempFile="/sys/class/thermal/thermal_zone0/temp"
  if [ ! -f $tempFile ]; then              # file not found
    echo "ERROR: did not find $tempFile"
    exit 1
  fi
  local theTemp=`cat /sys/class/thermal/thermal_zone0/temp` # in thousdandths of degrees celcius
  let theTemp=$theTemp/1000                # convert to degrees Celcius
  let tempF=$theTemp*9/5+32                # convert to degrees Farenheit
  echo "CPU temperature : ${theTemp}C / ${tempF}F"
 }                                         # listTemp()

#+--------------------------------------------------------------------------+
function tmpfsUsage()
# Is the directory passed in using a tmpfs? 
# Arg 1   : directory to mount
# Args 2-n:
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local theDir=$1
  shift
  local desc="$@"
  local answer

  mount | grep $theDir | grep tmpfs >/dev/null 2>&1
  if [ $? = 0 ]; then                      # directory is using a tmpfs       
    answer=yes
  else
    answer=no
  fi
  printf "%30s %16s : %s\n" "$theDir" "$desc" "$answer"
 }                                         # getCPU()

#+--------------------------------------------------------------------------+
function doList()
# List much information about the OVOS environment 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local service
  if [ "$clear" = "yes" ]; then            # clear the screen
    clear     
  fi

  # check OVOS services
  echo "$dashes"              
  echo "OVOS services:"
  listService ovos-phal-admin root
  for nextService in ovos-audio ovos-core ovos-listener ovos-media ovos-messagebus; do
    listService $nextService user   
  done
  echo "$dashes"              
  echo "pulseaudio service:"
  listService pulseaudio root              # always check for pulse
  echo "$dashes"              
  echo "mpd service:"
  listService mpd root

  echo "$dashes"              
  distro=`grep ^PRETTY /etc/os-release | awk -F'"' '{print $2}'` # get the pretty name
  OVOSver=`ovosver 2>/dev/null`
  if [ ${#OVOSver} = 0 ]; then             # did not get version
    OVOSver="unknown"
  fi

  # also list many other settings and status 
  local distro=`grep ^PRETTY /etc/os-release | awk -F'"' '{print $2}'` # get the pretty name
  printf "%16s: %s\n" "Distro" "$distro"
  printf "%16s: %s\n" "OVOS version" "$OVOSver"
  printf "%16s: %s\n" "VIRTUAL_ENV" "$VIRTUAL_ENV"
  # printf "%15s : %s\n" "PYTHONPATH" "$PYTHONPATH"

  local IPaddr=`hostname -I | awk '{print $1}'` # get the IP address
  printf "%16s: %s\n" "IP address" "$IPaddr"
  listTemp                                 # RasPi temperature

  # root file system usage
  local rootUsed=`df -h / | tail -1 | awk '{print $5}'`
  printf "%16s: %s\n" "Root fs usage" "$rootUsed"
  getCPU                                   # CPU usage

  # memory usage
  echo "Memory usage    :"
  free -h | sed 's/^/  /g'                 # add two leading spaces

  # are log directories using tmpfs? 
  echo "tmpfs filesystem?"
  tmpfsUsage /var/log/ Linux logs
  tmpfsUsage $HOME/.local/state/mycroft/ OVOS logs
  echo
 }                                         # doList()

#+--------------------------------------------------------------------------+
# Global variables"
clear="yes"                                # clear the screen
dashes="---------------------------------------------------------------------------------"
verbose=1                                 

# main()
parseArgs $@                               # parse arguments
doList                                     # create output  

